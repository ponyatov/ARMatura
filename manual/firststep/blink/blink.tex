\chapter{Первый проект: blink}\label{blink}

\bigskip
\includegraphics[width=\textwidth]{firststep/blink/125.jpg}

\bigskip
\includegraphics{firststep/blink/126.jpg}

\bigskip
\includegraphics[width=\textwidth]{firststep/blink/15.jpg}
\bigskip

При необходимости можно изменить настройки проекта см. \ref{keilconfig}.
Перенастройка может понадобиться если вы пытаетесь работать не с \stmvld, а с другой платой
или самопальной железкой. Также перенастройка может понадобится если почему-то не срабатывает
подключение к адаптеру \stlink.

\bigskip
Собираем проект, нажав клавишу \keys{F7}:

\bigskip
\includegraphics[width=\textwidth]{firststep/blink/8.jpg}
\bigskip

Проект успешно собрался, теперь можно проставить на \lstinline+loop()+ точку останова (breakpoint)
переместив курсор на заголовок функции и нажав кнопку \keys{F9}. При работе программы в отладочном
режиме работа программы останавливается на точках останова, позволяя посмотреть состояние регистров
процессора, переменных и т.п.

\bigskip
\includegraphics{firststep/blink/9.jpg}
\bigskip

Подключаем отладочную плату, а затем запускаем отладку нажав \keys{Ctrl+F5}:

\bigskip
\includegraphics{firststep/blink/10.jpg}
\bigskip

Вывалится диалог с сообщением об использовании оценочной версии \keil.

\bigskip
\includegraphics{firststep/blink/11.jpg}
\bigskip

После дрыганья окнами откроется отладочный режим:

\bigskip
\includegraphics[width=\textwidth]{firststep/blink/13.jpg}
\bigskip

В окне редактора автоматически откроется код \verb+SSAU.cpp+

В окне \verb+Register+ показыватся состояние регистров процессора, В верхней части
расположено окно дизасемблированного кода, снизу слева командная консоль отладчика,
снизу справа --- просмотр стека и памяти.

Подробно работа с отладчиком описана в разделе \ref{keildebug}, при желании вы можете
пройтись в пошаговом режиме (нажимая кнопку \keys{F11}) по коду,
и глядя в даташит на ваш микроконтроллер, попытаться разобраться что именно он делает.

Пока же разборки с работой в отладчике можно отложить, лучше вместо этого запустим программу 
на целевой плате, нажав \keys{F5}. Картинка не изменится, но плата должна запуститься и замигать
светодиодами: LD3 (зеленый) будет мигать с частотой $0.777ms \times 2=1.554$ Гц, а LD4 (синий)
будет переключаться с частотой 2 Гц асинхронно функцией \lstinline+tick1s()+, которую вызывает
обработчик системного таймера.

Проект по умолчанию настроен на запуск программы в SRAM\footnote{статическое ОЗУ}, не используя 
Flash --- эта фича \cortex{ов}
позволяет экономить циклы перезаписи флеша, но требует использования отладчика \keil, и позволяет
запускать только простые программы, т.к. ОЗУ у МК младших линеек очень мало, для платы \stmvld\
всего 8К.

Если вам не хватит SRAM для программы, или захочется получить автономное устройство, нужно будет
перенастроить проект под использование Flash:

\bigskip
\includegraphics{firststep/blink/204.jpg}
\bigskip

Выделен текущий процессор STM32F100RBT6, использующий внешний кварц 8 МГц.

Обратите внимание на настройки областей IR\emph{O}M1 и IR\emph{A}M1: обе области прописаны в область
SRAM контроллера, но на начало SRAM привязан IROM1, а на вторую половину ОЗУ --- IRAM1.
В результате при компиляции линкер генерирует код для исполнения из SRAM, а отладчик при своем запуске
прогрузит код, и выставит регистры, считав значения из таблицы векторов в начале стартового кода:
\begin{itemize}
  \item PC указатель выполняемой инструкции на начало кода инициализации в SRAM
  \item SP указатель стека на значение из таблицы векторов
  \item VTOR перенастроит на начало таблицы векторов в ОЗУ (вместо 0го адреса по умолчанию) 
\end{itemize}   

\bigskip
\includegraphics{firststep/blink/205.jpg}
\bigskip

Чтобы не возюкаться с ручным изменением адресов, нужно перейти на вкладку \keys{Device}, 
запомнить текущий МК, выбрать любой соседний контроллер, а затем еще раз выбрать нужный.
Цветом выделены размеры памяти --- 128К флеша и 8К ОЗУ.

\bigskip
\includegraphics{firststep/blink/206.jpg}
\bigskip

Теперь если еще раз выбрать вкладку \keys{Target}, в настройки областей памяти пропишуются
нужные значения для загрузки во флеш, а объем доступного ОЗУ увеличится:

\bigskip
\includegraphics{firststep/blink/207.jpg}
\bigskip

На вкладке \keys{C/\cpp} и \keys{Asm} нужно убрать дефайн \lstinline+VECT_TAB_SRAM+, включающий
в стартовом коде \verb+system_stm32fxyz.(c|h)+ использование таблицы векторов в SRAM:

\bigskip
\includegraphics{firststep/blink/211.jpg}
\bigskip

\emph{Теперь из-за глюка в \keil\ придется пройтись по настройкам отладчика и прошивальщика --- они почти
всегда слетают.}

На вкладке \keys{Debug}\ выберите \keys{ST-Link Debugger}, поставьте галку на загрузке приложения
(во флешь) при старте отладки, галку выполнять стартовый код до функции \lstinline+main()+, щелкните
кнопку \keys{Edit}\ для открытия .ini файла с процедурой запуска отладчика (далее ее нужно будет изменить),
и не забудьте щелкнуть кнопку \keys{Settings}\ около программатора чтобы поправить слетевшие настройки:   

\bigskip
\includegraphics{firststep/blink/209.jpg}
\bigskip

Выставьте \menu{Port:>SW} для использования интерфейса \swd\ вместо \jtag, которого нет в наплатном \stlink,
а на вкладке \keys{Flash Download}\ поставьте галку на \menu{Reset and Run}\ и проверьте значения в других полях: 

\bigskip
\includegraphics{firststep/blink/215.jpg}
\bigskip

\bigskip
\includegraphics{firststep/blink/216.jpg}
\bigskip

На вкладке \menu{Utilities}\ еще раз проставьте слетевший \stlink:

\bigskip
\includegraphics{firststep/blink/217.jpg}
\bigskip

Теперь осталось всего лишь \smiley\ отредактировать файл \verb+Dbg_RAM.ini+, закомментировав
загрузку регистров, и нажать \keys{Сtrl+S}\ для сохранения.

\bigskip
\includegraphics{firststep/blink/210.jpg}
\bigskip

Так подбробно перенастройка на использование флеш приведена здесь для того, чтобы при необходимости
вы сами смогли перенастроить проект в обратную сторону, если создадите его с нуля. Особое внимание
при этом обратите на поле дефайнов на вкладках \menu{C}\ и \menu{Asm}\ --- без них ваш код не будет
компилироваться. 

\bigskip

После сохранения настроек проекта осталось запустить прошивку программы:

\bigskip
\includegraphics{firststep/blink/14.jpg}
\bigskip

Запускается прошивка флешпамяти на отладочной плате, на программаторе мигает светодиод передачи данных,
и после успешной прошивки наша плата начинает мигать светодиодами.

\bigskip

В качестве первой практической работы вы можете открыть новое окно \keil, и создать в нем новый проект,
сохранив его куда-нибудь в \menu{.>keil>UserProject01.uvproj}, а затем попытаться повторить
структуру файлов (описана в следующем разделе) и настройки проекта так, чтобы он у вас собрался и
заработал в режиме отладки (с компиляцией в SRAM) и в конечном варианте (с прошивкой во флешь).
Замените файл \verb+blink.cpp+\ на свой \menu{src>user>game.cpp}\ чтобы можно было экспериментировать
со своим кодом не потерев примеры проектов.

\section{Структура файлов}

\dirtree{%
.1 WorkSpace.
.2 \stmvld.
.3 src.
.4 blink.cpp \DTcomment{мигалка светодиодами}.
.3 config \DTcomment{файлы с настройками проекта}.
.4 SSAU.h \DTcomment{Настройки библиотеки SSAU \wiring}.
.4 Dbg\_RAM.ini \DTcomment{настройки отладки в SRAM}.
.3 SSAU \DTcomment{\wiring-совместимая \cpp\ библиотека}.
.4 SSAU.cpp.
.3 BSP \DTcomment{Board Support Package}.
.4 STM32vldiscovery.c.
.5 STM32vldiscovery.h.
.3 startup \DTcomment{код инициализации ядра процессора}.
.4 startup\_stm32f10x\_ld\_vl.s \DTcomment{ассемблерный код инициализации}.
.4 system\_stm32f10x.c \DTcomment{сишный код инициализации}.
.5 system\_stm32f10x.h.
.5 stdint.h \DTcomment{стандартные целые типы \cpp}.
.5 core\_cm3.h \DTcomment{\cmsis\ библиотека поддержки ядра \cortex{M3}}.
.5 core\_cmInstr.h \DTcomment{\cmsis\ Core Instruction Interface}.
.5 core\_cmFunc.h \DTcomment{\cmsis\ Core Register Access Functions}.
.5 stm32f10x.h.
.3 \cmsis.
.4 misc.c.
.4 stm32f10x\_rcc.c.
.4 stm32f10x\_gpio.c \DTcomment{джигадрыга}.
.2 \stmdisco.
.3 startup.
.4 startup\_stm32f40xx.s.
.4 system\_stm32f4xx.c.
.5 system\_stm32f4xx.h.
.5 core\_cm4.h \DTcomment{\cmsis\ библиотека поддержки ядра \cortex{M4}}.
.5 core\_cm4\_simd.h \DTcomment{\cmsis\ \cortex{M4} расширение SIMD/DSP}.
.5 stm32f4xx.h.
.3 \cmsis.
.3 src.
.3 SSAU.
.3 BSP.
.4 STM32f4\_discovery.c.
.5 STM324\_discovery.h.
.2 \stmzero.
.2 STM32EMU103.
}


\bigskip

В отличие от кристаллов типа Atmel AVR, при программировании для архитектуры \cortex{Mx}
принято использовать готовую библиотеку \cmsis,
для которой проводится активная стандартизация среди производителей процессоров.

\bigskip
\menu{Cortex>Microcontroller>Software>Interface>Standard}
\bigskip

\bigskip
\url{http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php}
\bigskip

Кроме основной части \cmsis, общей для всех производителей МК \cortex{Mx}, каждый подставщик
предоставляет аппаратно-зависимую часть библиотеки:
\begin{itemize}
  \item стартовый код инициализации ядра процессора
  \item библиотеку периферии например STM32F Standard Peripherial Library, включающую код
  обеспечивающий доступ к устройствам, встроенным в кристалл в т.ч.
  \item USB OTG Host \& Device
  \item DSP/SIMD Extension (для \cortex{M4F}) системо-зависимую часть расширения \cmsis\ DSP
\end{itemize}

\bigskip
Список ссылок для загрузки библиотек см. \ref{CMSIS}.

\section{blink.cpp}

Сначала поcмотрим код основной программы:

\lstinputlisting[
	label=blink.cpp,
	caption={[blink.c]/src/blink/blink.cpp}
]{firststep/blink/blink.cpp}

Как видим --- в ней нет абсолютно ничего сложного: только подключение библиотеки
\wiring, две типовые функции \lstinline+setup()+\ и \lstinline+loop()+,
и новая функция \lstinline+tick1s()+, срабатывающая каждую секунду от таймера
асинхронно основной программе.

\bigskip
\emph{При активном использовании \lstinline+tick1s()+ нужно быть аккуратнее, чем
с обычной адуриной --- код должен быть \emph{thread-safe}, т.е. нужно учитывать
что ваша программа может быть прервана в любой точке, и запущена функция \lstinline+tick1s()+.
Если вы выполняете какие-то действия с периферией или со структурами данных и в основном
коде, и в функции \lstinline+tick1s()+, возможны всякие детские неожиданности, 
характерные для многозадачного программирования.}
\bigskip

Файлы разделов \verb+CMSIS+, \verb+BSP+\ и \verb+SSAU+\ подробно 
рассмотрены далее в отдельных главах. На текущем
слое знаний не стоит в них углубляться: для начала лучше заставить вашу плату работать,
и выполнять какие-то простые бесполезные функции, а подробности библиотек изучим 
позднее.
