\part{VCS: управление версиями}

Для реальных проектов, даже состоящих из пары файлов, всегда\footnote{кроме
индивидуумов, контуженных Паскалем}\ используются системы контроля версий (VCS)\ ---
некая база данных, в которой хранятся исходные тексты и бинарные ресурсы (таблицы,
битмапы, сторонние библиотеки в бинарниках, аудиофайлы\etc).

Эта база (репозиторий проекта) хранит \emph{полную историю} всех изменений,
выполненных в файлах пректа, и позволяет получить исходные тексты на любой
момент разработки, вести несколько альтернативных веток разработки,
выяснить кто когда и что делал, и кто что и когда сломал.

\url{http://ru.wikipedia.org/wiki/VCS}

Система управления версиями (от англ. Version Control System, VCS или Revision 
Control System) — программное обеспечение для облегчения работы с изменяющейся 
информацией. Система управления версиями позволяет хранить несколько версий 
одного и того же документа, при необходимости возвращаться к более ранним 
версиям, определять, кто и когда сделал то или иное изменение, и многое другое.

Такие системы наиболее широко используются при разработке программного обеспечения 
для хранения исходных кодов разрабатываемой программы. Однако они могут с успехом 
применяться и в других областях, в которых ведётся работа с большим количеством 
непрерывно изменяющихся электронных документов. В частности, системы управления 
версиями применяются в САПР, обычно в составе систем управления данными об 
изделии (PDM). Управление версиями используется в инструментах конфигурационного 
управления (Software Configuration Management Tools).

Ситуация, в которой электронный документ за время своего существования претерпевает 
ряд изменений, достаточно типична. При этом часто бывает важно иметь не только 
последнюю версию, но и несколько предыдущих. В простейшем случае можно просто 
хранить несколько вариантов документа, нумеруя их соответствующим образом. Такой 
способ неэффективен (приходится хранить несколько практически идентичных копий), 
требует повышенного внимания и дисциплины и часто ведёт к ошибкам, поэтому были 
разработаны средства для автоматизации этой работы.

Традиционные системы управления версиями используют централизованную модель, когда 
имеется единое хранилище документов, управляемое специальным сервером, который и 
выполняет большую часть функций по управлению версиями. Пользователь, работающий 
с документами, должен сначала получить нужную ему версию документа из хранилища; 
обычно создаётся локальная копия документа, т. н. «рабочая копия». Может быть 
получена последняя версия или любая из предыдущих, которая может быть выбрана по 
номеру версии или дате создания, иногда и по другим признакам. После того, как в 
документ внесены нужные изменения, новая версия помещается в хранилище. В отличие 
от простого сохранения файла, предыдущая версия не стирается, а тоже остаётся в 
хранилище и может быть оттуда получена в любое время.

Часто бывает, что над одним проектом одновременно работают несколько человек. Если 
два человека изменяют один и тот же файл, то один из них может случайно отменить 
изменения, сделанные другим. Системы управления версиями отслеживают такие конфликты 
и предлагают средства их решения. Большинство систем может автоматически объединить 
(слить) изменения, сделанные разными разработчиками. Однако такое автоматическое 
объединение изменений, обычно, возможно только для текстовых файлов и при условии, 
что изменялись разные (непересекающиеся) части этого файла.

Часто выполнить слияние невозможно ни в автоматическом, ни в ручном режиме, например, 
если формат файла неизвестен или слишком сложен. Некоторые системы управления 
версиями дают возможность заблокировать файл в хранилище. Блокировка не позволяет 
другим пользователям получить рабочую копию или препятствует изменению рабочей 
копии файла (например, средствами файловой системы) и обеспечивает, таким образом, 
исключительный доступ только тому пользователю, который работает с документом.

\paragraph{Распределённые системы управления версиями} также известны как англ. 
Dis\-tri\-bu\-ted Version Control System, DVCS. Такие системы используют распределённую 
модель вместо традиционной клиент-серверной. Они, в общем случае, не нуждаются в 
централизованном хранилище: вся история изменения документов хранится на каждом 
компьютере, в локальном хранилище, и при необходимости отдельные фрагменты истории 
локального хранилища синхронизируются с аналогичным хранилищем на другом компьютере. 
В некоторых таких системах локальное хранилище располагается непосредственно в 
каталогах рабочей копии.

Когда пользователь такой системы выполняет обычные действия, такие как извлечение 
определённой версии документа, создание новой версии и тому подобное, он работает со 
своей локальной копией хранилища. По мере внесения изменений, хранилища, принадлежащие 
разным разработчикам, начинают различаться, и возникает необходимость в их 
синхронизации.

Описанная модель логически близка созданию отдельной ветки для каждого разработчика в 
классической системе управления версиями (в некоторых распределённых системах перед 
началом работы с локальным хранилищем нужно создать новую ветвь). Отличие состоит в 
том, что до момента синхронизации другие разработчики этой ветви не видят. Пока 
разработчик изменяет только свою ветвь, его работа не влияет на других участников 
проекта и наоборот. По завершении обособленной части работы, внесённые в ветви 
изменения сливают с основной (общей) ветвью. Как при слиянии ветвей, так и при 
синхронизации разных хранилищ возможны конфликты версий. На этот случай во всех 
системах предусмотрены те или иные методы обнаружения и разрешения конфликтов слияния.

С точки зрения пользователя распределённая система отличается необходимостью 
создавать локальный репозиторий и наличием в командном языке двух дополнительных 
команд: команды получения репозитория от удалённого компьютера (pull) и передачи 
своего репозитория на удалённый компьютер (push). Первая команда выполняет слияние 
изменений удалённого и локального репозиториев с помещением результата в локальный 
репозиторий; вторая — наоборот, выполняет слияние изменений двух репозиториев с 
помещением результата в удалённый репозиторий. Как правило, команды слияния в 
распределённых системах позволяют выбрать, какие наборы изменений будут передаваться 
в другой репозиторий или извлекаться из него, исправлять конфликты слияния 
непосредственно в ходе операции или после её неудачного завершения, повторять или 
возобновлять неоконченное слияние. Обычно передача своих изменений в чужой репозиторий 
(push) завершается удачно только при условии отсутствия конфликтов. Если конфликты 
возникают, пользователь должен сначала слить версии в своём репозитории (выполнить 
pull), и лишь затем передавать их другим.

Обычно рекомендуется организовывать работу с системой так, чтобы пользователи всегда 
или преимущественно выполняли слияние у себя в репозитории. То есть, в отличие от 
централизованных систем, где пользователи передают свои изменения на центральный 
сервер, когда считают нужным, в распределённых системах более естественным является 
порядок, когда слияние версий инициирует тот, кому нужно получить его результат 
(например, разработчик, управляющий сборкой дистрибутива для передачи его на конечное
тестирование).

Основные преимущества распределённых систем — их гибкость и значительно большая (по 
сравнению с централизованными системами) автономия отдельного рабочего места. Каждый 
компьютер разработчика является, фактически, самостоятельным и полнофункциональным 
сервером. При этом каждый разработчик может вести работу независимо, так, как ему 
удобно, изменяя и сохраняя промежуточные версии документов, пользуясь всеми 
возможностями системы (в том числе доступом к истории изменений) даже в отсутствие 
сетевого соединения. Связь с сервером или другими разработчиками требуется исключительно 
для проведения синхронизации.

К недостатком распределённых систем можно отнести увеличение требуемого объёма 
дисковой памяти: на каждом компьютере приходится хранить полную историю версий, тогда 
как в централизованной системе на компьютере разработчика обычно хранится лишь рабочая 
копия.

Можно выделить следующие типичные ситуации, в которых использование распределённой 
системы даёт заметные преимущества:

\begin{itemize}
\item Периодическая синхронизация нескольких компьютеров под управлением одного 
разработчика (рабочего компьютера, домашнего компьютера, ноутбука и так далее). 
Использование распределённой системы избавляет от необходимости выделять один из 
компьютеров в качестве сервера, а синхронизация выполняется по необходимости, обычно 
при «пересадке» разработчика с одного устройства на другое.
\item Совместная работа над проектом небольшой территориально распределённой группы 
разработчиков без выделения общих ресурсов. Как и в предыдущем случае, реализуется 
схема работы без главного сервера, а актуальность репозиториев поддерживается 
периодическими синхронизациями по схеме «каждый с каждым».
\item Крупный распределённый проект, участники которого могут долгое время работать 
каждый над своей частью, при этом не имеют постоянного подключения к сети. Такой 
проект может использовать централизованный сервер, с которым синхронизируются копии 
всех его участников. Возможны и более сложные варианты — например, с созданием групп 
для работы по отдельным направлениям внутри более крупного проекта. При этом могут 
быть выделены отдельные «групповые» серверы для синхронизации работы групп, тогда 
процесс окончательного слияния изменения становится древовидным: сначала отдельные 
разработчики синхронизируют изменения на групповых серверах, затем обновлённые 
репозитории групп синхронизируются с главным сервером. Возможна работа и без 
«групповых» серверов, тогда разработчики одной группы синхронизируют изменения между 
собой, после чего любой из них (например, руководитель группы) передаёт изменения 
на центральный сервер.
\end{itemize}

\bigskip
Проект \armatura\ хранится в публичном репозитории 
\url{git@github.com:ponyatov/ARMatura.git} используя систему контроля версий Git.

\input{versioncontrol/git}
\input{versioncontrol/svn}
\input{versioncontrol/cvs}
\input{versioncontrol/mercurial}
\input{versioncontrol/bazaar}

